<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//unpkg.com/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//unpkg.com/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="前言记录一下一些Python的知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="Python知识点">
<meta property="og:url" content="http://example.com/2021/11/07/Python%E6%8B%BE%E9%81%97/index.html">
<meta property="og:site_name" content="木霈玖的博客">
<meta property="og:description" content="前言记录一下一些Python的知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/shallow.png">
<meta property="og:image" content="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/deep.png">
<meta property="og:image" content="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/202305131448838.png">
<meta property="article:published_time" content="2021-11-07T14:21:38.000Z">
<meta property="article:modified_time" content="2025-03-17T12:14:31.714Z">
<meta property="article:author" content="木霈玖">
<meta property="article:tag" content="总结">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/shallow.png">


<link rel="canonical" href="http://example.com/2021/11/07/Python%E6%8B%BE%E9%81%97/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Python知识点 | 木霈玖的博客</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">木霈玖的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="nav-number">2.2.</span> <span class="nav-text">标记-清除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="nav-number">2.3.</span> <span class="nav-text">分代回收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">整数缓存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">字典核心底层原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A4%E6%96%AD"><span class="nav-number">6.</span> <span class="nav-text">判断</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6else%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.1.</span> <span class="nav-text">for…else循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">9.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LEGB%E8%A7%84%E5%88%99"><span class="nav-number">10.</span> <span class="nav-text">LEGB规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MRO"><span class="nav-number">11.</span> <span class="nav-text">MRO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">12.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sys-path%E5%92%8C%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2"><span class="nav-number">13.</span> <span class="nav-text">sys.path和模块路径搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">进程和线程区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#yield%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">15.1.</span> <span class="nav-text">yield的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#send%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">15.2.</span> <span class="nav-text">send的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">15.3.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">15.4.</span> <span class="nav-text">task的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%9B%9E%E8%B0%83"><span class="nav-number">15.5.</span> <span class="nav-text">绑定回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="nav-number">15.6.</span> <span class="nav-text">协程阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">15.7.</span> <span class="nav-text">协程并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%B5%8C%E5%A5%97"><span class="nav-number">15.8.</span> <span class="nav-text">协程嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%81%9C%E6%AD%A2"><span class="nav-number">15.9.</span> <span class="nav-text">协程停止</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">16.</span> <span class="nav-text">网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI%E6%A8%A1%E5%9E%8B"><span class="nav-number">16.1.</span> <span class="nav-text">OSI模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE"><span class="nav-number">16.2.</span> <span class="nav-text">TCP&#x2F;IP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-UDP"><span class="nav-number">16.3.</span> <span class="nav-text">TCP&#x2F;UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">16.3.1.</span> <span class="nav-text">TCP三次握手</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TFTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">16.4.</span> <span class="nav-text">TFTP协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">17.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0map"><span class="nav-number">17.1.</span> <span class="nav-text">高阶函数map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0reduce"><span class="nav-number">17.2.</span> <span class="nav-text">高阶函数reduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0filter"><span class="nav-number">17.3.</span> <span class="nav-text">高阶函数filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0sorted"><span class="nav-number">17.4.</span> <span class="nav-text">高阶函数sorted</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0zip"><span class="nav-number">17.5.</span> <span class="nav-text">高阶函数zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">17.6.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">17.7.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">17.8.</span> <span class="nav-text">装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-number">17.9.</span> <span class="nav-text">偏函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">17.10.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6"><span class="nav-number">17.10.1.</span> <span class="nav-text">常用字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">17.10.2.</span> <span class="nav-text">重复限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%AD%97%E7%AC%A6"><span class="nav-number">17.10.3.</span> <span class="nav-text">边界字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A9%E4%B8%80%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">17.10.4.</span> <span class="nav-text">择一匹配字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84"><span class="nav-number">17.10.5.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match%E6%96%B9%E6%B3%95"><span class="nav-number">17.10.6.</span> <span class="nav-text">match方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search%E6%96%B9%E6%B3%95"><span class="nav-number">17.10.7.</span> <span class="nav-text">search方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub%E5%92%8Csubn%E5%87%BD%E6%95%B0"><span class="nav-number">17.10.8.</span> <span class="nav-text">sub和subn函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compile%E5%87%BD%E6%95%B0"><span class="nav-number">17.10.9.</span> <span class="nav-text">compile函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#findall%E5%87%BD%E6%95%B0"><span class="nav-number">17.10.10.</span> <span class="nav-text">findall函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finditer%E5%87%BD%E6%95%B0"><span class="nav-number">17.10.11.</span> <span class="nav-text">finditer函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#split%E5%87%BD%E6%95%B0"><span class="nav-number">17.10.12.</span> <span class="nav-text">split函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.10.13.</span> <span class="nav-text">贪婪模式和非贪婪模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.10.14.</span> <span class="nav-text">type类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">17.11.</span> <span class="nav-text">一些库的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bisect%E5%BA%93"><span class="nav-number">17.11.1.</span> <span class="nav-text">bisect库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heapq%E5%BA%93"><span class="nav-number">17.11.2.</span> <span class="nav-text">heapq库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#functools%E5%BA%93"><span class="nav-number">17.11.3.</span> <span class="nav-text">functools库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#argparse%E5%BA%93"><span class="nav-number">17.11.4.</span> <span class="nav-text">argparse库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#argparse%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-number">17.11.4.1.</span> <span class="nav-text">argparse定义四个步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#os%E5%BA%93"><span class="nav-number">17.11.5.</span> <span class="nav-text">os库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#os-path-realpath%E5%92%8Cos-path-abspath"><span class="nav-number">17.11.5.1.</span> <span class="nav-text">os.path.realpath和os.path.abspath</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E8%BE%A8%E6%9E%90"><span class="nav-number">18.</span> <span class="nav-text">函数与方法辨析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%AE%BA"><span class="nav-number">18.1.</span> <span class="nav-text">推论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">19.</span> <span class="nav-text">多线程&#x2F;多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">19.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="nav-number">19.1.1.</span> <span class="nav-text">锁（Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%88Critical-Section%EF%BC%89"><span class="nav-number">19.1.2.</span> <span class="nav-text">临界区（Critical Section）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%EF%BC%89"><span class="nav-number">19.1.3.</span> <span class="nav-text">条件变量（Condition）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">19.2.</span> <span class="nav-text">实例分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">木霈玖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/Python%E6%8B%BE%E9%81%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="木霈玖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木霈玖的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python知识点
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-07 22:21:38" itemprop="dateCreated datePublished" datetime="2021-11-07T22:21:38+08:00">2021-11-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-03-17 20:14:31" itemprop="dateModified" datetime="2025-03-17T20:14:31+08:00">2025-03-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下一些Python的知识点</p>
<a id="more"></a>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83251959">Python垃圾回收机制！非常实用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fat-girl-spring/p/15094805.html">Python垃圾回收机制</a></li>
</ol>
<p>Python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line"> <span class="keyword">int</span> ob_refcnt;</span><br><span class="line"> struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>以下情况是导致引用计数加一的情况:</p>
<ul>
<li>对象被创建，例如a=2</li>
<li>对象被引用，b=a</li>
<li>对象被作为参数，传入到一个函数中</li>
<li>对象作为一个元素，存储在容器中</li>
</ul>
<p>下面的情况则会导致引用计数减一:</p>
<ul>
<li>对象别名被显式销毁 del</li>
<li>对象别名被赋予新的对象</li>
<li>一个对象离开他的作用域</li>
<li>对象所在的容器被销毁或者是从容器中删除对象</li>
</ul>
<p>引用计数机制的优点：</p>
<ol>
<li>简单</li>
<li>实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li>
</ol>
<p>引用计数机制的缺点：</p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<p>list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。</p>
<h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>Python采用了<strong>“标记-清除”(Mark and Sweep)</strong>算法，解决容器对象可能产生的循环引用问题。（注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列）</p>
<p>该算法在进行垃圾回收时分成了两步，分别是：</p>
<ul>
<li>A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；</li>
<li>B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</li>
</ul>
<p>在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。每一个节点除了有一个记录当前引用计数的变量ref_count还有一个gc_ref变量，这个gc_ref是ref_count的一个副本，所以初始值为ref_count的大小。</p>
<p>过程：</p>
<ol>
<li>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的gc_ref减一。</li>
<li>接着，gc会再次扫描所有的容器对象，如果对象的gc_ref值为0，那么这个对象就被标记为GC_TENTATIVELY_UNREACHABLE，并且被移至”Unreachable”链表中。</li>
<li>如果对象的gc_ref不为0，那么这个对象就会被标记为GC_REACHABLE。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为GC_REACHABLE。</li>
<li>除了将所有可达节点标记为GC_REACHABLE之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中。</li>
<li>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。</li>
</ol>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过<strong>“分代回收”(Generational Collection)</strong>以空间换时间的方法提高垃圾回收效率。</p>
<p>分代回收是基于这样的一个统计事实，<strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p>
<p>gc的扫描在什么时候会被触发呢?答案是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure>
<p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p>
<h1 id="整数缓存问题"><a href="#整数缓存问题" class="headerlink" title="整数缓存问题"></a>整数缓存问题</h1><p>Python仅仅对比较小的整数对象进行缓存（范围为[-5,256]），而并非所有的整数对象。需要注意的是，这仅仅是在<strong>命令行</strong>中执行，而在Pycharm或保存为文件执行，结果是不一样的，因为解释器做了一部分优化（范围变成了[-5, 任意正整数]）（注：自己在Pycharm中实践发现小于-5的好像也可）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1000</span></span><br><span class="line">b = <span class="number">1000</span></span><br><span class="line">a <span class="keyword">is</span> b <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line">a <span class="keyword">is</span> b <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol>
<li>字符串拼接尽量使用<code>join()</code>而不是<code>+=</code>，因为<code>+=</code>每次会创建新对象</li>
<li><strong>字符串驻留</strong>：仅保存一份相同且不可变的字符串的方法，不同的值被存放在字符串驻留池中。Python支持字符串驻留机制，对于符合标识规则的字符串（仅包含下划线<code>_</code>，字母和数字）会启用字符串驻留机制。（似乎Pycharm中不需要满足命名规则）</li>
</ol>
<h1 id="字典核心底层原理"><a href="#字典核心底层原理" class="headerlink" title="字典核心底层原理"></a>字典核心底层原理</h1><p>字典对象核心是散列表。散列表是一个稀疏数组（总有空白元素的数组），数组的每个单元叫做bucket。每个bucket有两个部分：一是键对象的引用，一个是值对象的引用。可以通过偏移量来读取指定的bucket。</p>
<p>键值对放进字典的底层过程：</p>
<ol>
<li>计算见的散列值，python中通过<code>hash()</code>来计算。</li>
<li>查看偏移量对应的bucket是否为空，如果为空，则放入。如果不为空，则取新的偏移量，查看新偏移量对应的bucket是否为空，直到找到空的bucket存放。</li>
<li>如果数组2/3已经满了，自动扩容，已存放的自动复制</li>
</ol>
<p>根据键查找键值对的底层过程：</p>
<ol>
<li>算散列值</li>
<li>根据散列值找bucket，bucket为空，返回None；bucket不为空则取出键，并计算新散列值，比较第一步的散列值和当前散列值是否相同。相同返回，不同则继续取新的散列值。</li>
</ol>
<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p><code>if not A</code> 和 <code>if A is None</code> 看起来都是在判断<code>A</code>是否为<strong>空</strong>，实际上这两者是不同的：</p>
<ul>
<li><code>if not A</code> 判断的是<code>A</code>是否为<strong>空</strong>，也就是说里面有东西没？</li>
<li><code>if A is None</code>则判断的是<code>A</code>是否<strong>声明并定义</strong>了？</li>
</ul>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>在Python里，函数的默认值是在函数的定义时实例化的，而不是调用时。当且仅当默认参数所在的“def”语句执行的时候，默认值才会进行计算。“def”是Python的可执行语句，默认参数在“def”的语句环境里被计算。如果执行多次“def”语句，每次都会创建一个新的参数对象。</p>
<p>为什么调用函数的时候，这个默认值却被赋予了不同的值呢？因为在每次给函数指定一个默认值的时候，Python都会存储这个值。如果在调用函数的时候重写了默认值，那么这个存储的值就不会被使用。当不重写默认值的时候，那么Python就会让默认值引用存储的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, lst=[]</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">        lst.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    list1 = add(<span class="number">1</span>)</span><br><span class="line">    print(list1)</span><br><span class="line"></span><br><span class="line">    list2 = add(<span class="number">2</span>)</span><br><span class="line">    print(list2)</span><br><span class="line"></span><br><span class="line">    list3 = add(<span class="number">3</span>, [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">    print(list3)</span><br><span class="line"></span><br><span class="line">    list4 = add(<span class="number">4</span>)</span><br><span class="line">    print(list4)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>我们以为的输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>实际的输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>为了更好地理解调用情况，可以在add函数中输出lst的id，如以下代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, lst=[]</span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>(lst))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">        lst.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    list1 = add(<span class="number">1</span>)</span><br><span class="line">    print(list1)</span><br><span class="line"></span><br><span class="line">    list2 = add(<span class="number">2</span>)</span><br><span class="line">    print(list2)</span><br><span class="line"></span><br><span class="line">    list3 = add(<span class="number">3</span>, [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">    print(list3)</span><br><span class="line"></span><br><span class="line">    list4 = add(<span class="number">4</span>)</span><br><span class="line">    print(list4)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4469603648</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="number">4469603648</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">4469670472</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">4469603648</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>如何避免踩坑呢？建议的正确代码的形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, lst=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        lst = []</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">        lst.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    list1 = add(<span class="number">1</span>)</span><br><span class="line">    print(list1)</span><br><span class="line"></span><br><span class="line">    list2 = add(<span class="number">2</span>)</span><br><span class="line">    print(list2)</span><br><span class="line"></span><br><span class="line">    list3 = add(<span class="number">3</span>, [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">    print(list3)</span><br><span class="line"></span><br><span class="line">    list4 = add(<span class="number">4</span>)</span><br><span class="line">    print(list4)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>代码优化：</p>
<ol>
<li>尽量减少循环内部不必要的计算</li>
<li>嵌套循环中，尽量减少内层循环的计算，尽可能向外提</li>
<li>局部变量查询较快，尽量使用局部变量</li>
</ol>
<h2 id="for…else循环"><a href="#for…else循环" class="headerlink" title="for…else循环"></a>for…else循环</h2><p>当迭代的对象迭代完并为空时，位于else的子句将执行，而如果在for循环中含有break时则直接终止循环，并不会执行else子句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2022/2/24 18:51</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">f&quot;Find <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;Not find&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>预期的结果是找到5时打印出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Find <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用</p>
<p>深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象</p>
<p><strong>浅拷贝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">b_shallow = copy.copy(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">print(<span class="string">&quot;b_shallow:&quot;</span>, b_shallow)</span><br><span class="line"></span><br><span class="line">b_shallow.append(<span class="number">60</span>)</span><br><span class="line">b_shallow[<span class="number">2</span>].append(<span class="number">70</span>)</span><br><span class="line">print(<span class="string">&quot;######浅拷贝后######&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">print(<span class="string">&quot;b_shallow:&quot;</span>, b_shallow)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a: [10, 20, [30, 40]]</span></span><br><span class="line"><span class="comment"># b_shallow: [10, 20, [30, 40]]</span></span><br><span class="line"><span class="comment"># ######浅拷贝后######</span></span><br><span class="line"><span class="comment"># a: [10, 20, [30, 40, 70]]</span></span><br><span class="line"><span class="comment"># b_shallow: [10, 20, [30, 40, 70], 60]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/shallow.png" alt="浅拷贝"><strong>深拷贝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">b_deep = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">print(<span class="string">&quot;b_deep:&quot;</span>, b_deep)</span><br><span class="line"></span><br><span class="line">b_deep.append(<span class="number">60</span>)</span><br><span class="line">b_deep[<span class="number">2</span>].append(<span class="number">70</span>)</span><br><span class="line">print(<span class="string">&quot;######深拷贝######&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">print(<span class="string">&quot;b_deep:&quot;</span>, b_deep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a: [10, 20, [30, 40]]</span></span><br><span class="line"><span class="comment"># b_deep: [10, 20, [30, 40]]</span></span><br><span class="line"><span class="comment"># ######深拷贝######</span></span><br><span class="line"><span class="comment"># a: [10, 20, [30, 40]]</span></span><br><span class="line"><span class="comment"># b_deep: [10, 20, [30, 40, 70], 60]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/deep.png" alt="深拷贝"></p>
<h1 id="LEGB规则"><a href="#LEGB规则" class="headerlink" title="LEGB规则"></a>LEGB规则</h1><p>Python在查找名称时，是按照LEGB规则查找的：Local $\longrightarrow$ Enclosed $\longrightarrow$ Global $\longrightarrow$ Built in</p>
<ul>
<li>Local：指的是函数或者类的方法的内部</li>
<li>Enclosed：指的是嵌套函数（一个函数内包裹另一个函数，闭包）</li>
<li>Global：指的是模块中的全局变量</li>
<li>Built in：指的是Python为自己保留的特殊名称</li>
</ul>
<h1 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h1><p>Python支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将“从左到右”顺序搜索。</p>
<p>MRO（Method Resolution Order）：方法解析顺序。我们可以通过<code>mro()</code>方法获取类的层次结构，方法也是按照这个类的层次结构寻找的。</p>
<p>子类和父类同时实现某个方法，根据<code>MRO</code>原则，调用子类的方法。下述例子输出<code>B load</code>，其层次结构为<code>[&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A load&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;B load&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = B()</span><br><span class="line">c.load()</span><br><span class="line">print(B.mro())</span><br></pre></td></tr></table></figure>
<p>子类继承多个父类，子类没有实现某个方法但多个父类都实现了该方法，根据<code>MRO</code>原则，从左到右搜索，即先继承的类先调用。下述例子输出<code>A load</code>，其层次结构为<code>[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A load&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;B load&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.load()</span><br><span class="line">print(C.mro())</span><br></pre></td></tr></table></figure>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>Serialization系列化，将内存中对象存储下来，变成一个个字节。</p>
<p>deSerialization反序列化，将文件的一个个字节到内存中。</p>
<p>序列化保存到文件就是持久化。</p>
<p>可将数据序列化后持久化，或者网络传输，也可以将文件中或者网络接受到的字节序列反序列化。</p>
<h1 id="sys-path和模块路径搜索"><a href="#sys-path和模块路径搜索" class="headerlink" title="sys.path和模块路径搜索"></a>sys.path和模块路径搜索</h1><p>当我们导入某个模块文件时，<code>Python</code>解释器一般按照以下路径寻找模块文件（按照顺序寻找，找到即停不继续往下寻找）：</p>
<ol>
<li>内置模块</li>
<li>当前目录</li>
<li>程序的主目录</li>
<li><code>pythonpath</code>目录（如果已经设置了<code>pythonpath</code>环境变量）</li>
<li>标准链接库目录</li>
<li>第三方库目录（<code>site-packages</code>目录）</li>
<li><code>.pth</code>文件的内容（如果存在的话）</li>
<li><code>sys.path.append()</code>临时添加的目录</li>
</ol>
<h1 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h1><div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>根本区别</td>
<td>作为资源分配的单位</td>
<td>调度和执行的单位</td>
</tr>
<tr>
<td>开销</td>
<td>每个进程都有独立的代码和数据空间，进程间的切换会有较大的开销</td>
<td>线程可以看成是轻量级的进程，多个线程共享内存，线程切换的开销小</td>
</tr>
<tr>
<td>所处环境</td>
<td>在操作系统中，同时运行的多个任务</td>
<td>在程序中多个顺序流同时执行</td>
</tr>
<tr>
<td>分配内存</td>
<td>系统在运行的时候为每一个进程分配不同的内存区域</td>
<td>线程使用的资源是他所属进程的资源</td>
</tr>
<tr>
<td>包含关系</td>
<td>一个进程可以拥有多个线程</td>
<td>线程是进程的一部分，所有线程有时候称为是轻量级的进程</td>
</tr>
</tbody>
</table>
</div>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程，又称微线程，纤程。英文名Coroutine，是一种用户态的轻量级线程。</p>
<p>子程序，或者称为函数，在所有的语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用时通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>线程是<strong>系统</strong>级别的，他们由操作系统调度，而协程则是<strong>程序</strong>级别的，由程序根据需要自己调度。在一个线程中会有很多函数，我们把这些函数称为子程序，在子程序的执行过程中可以中断去执行别的子程序，而别的子程序也可以中断回来继续执行之前的子程序，这个过程就称为协程。也就是说同一线程内一段代码在执行过程中会中断然后跳转执行别的代码，接着在之前中断的地方继续开始执行。</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<p><strong>优点</strong></p>
<ul>
<li>无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>无法利用多核资源：协程的本质是个单线程，它不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU上。当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。</li>
</ul>
<h2 id="yield的使用"><a href="#yield的使用" class="headerlink" title="yield的使用"></a>yield的使用</h2><p>在函数中使用了yield，则该函数就成为了一个生成器。<br>yield的理解：</p>
<ol>
<li>当成return，程序返回</li>
<li>当成生成器</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 15:24</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在函数中使用了yield，则该函数就成为了一个生成器</span></span><br><span class="line"><span class="string">yield的理解：</span></span><br><span class="line"><span class="string">（1）当成return，程序返回</span></span><br><span class="line"><span class="string">（2）当成生成器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure>
<h2 id="send的使用"><a href="#send的使用" class="headerlink" title="send的使用"></a>send的使用</h2><ol>
<li>除了可以使用next()函数唤醒生成器继续执行外，还可以使用send()函数唤醒执行。</li>
<li>使用send()函数的优点之一是可以在唤醒的同时将附加数据传输到断点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 16:00</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">f&quot;res:<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(g.send(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步：先执行第一个事务，如果遇到阻塞，会一直等待，直到第一个事务执行完毕，才会执行第二个事务。</p>
<p>异步：与同步是相对的，指执行第一个事务的时候，如果遇到阻塞，会直接执行第二个事务，不会等待。通过状态、通知、回调来执行。</p>
<h2 id="task的使用"><a href="#task的使用" class="headerlink" title="task的使用"></a>task的使用</h2><p>协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务(task)对象。所谓task对象是future类的子类。保存了协程运行后的状态，用于未来获取协程的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 16:38</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;waiting:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = do_work(<span class="number">3</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># loop.run_until_complete(coroutine)</span></span><br><span class="line"><span class="comment"># 创建任务的方式1</span></span><br><span class="line"><span class="comment"># task = asyncio.ensure_future(coroutine)</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(task)</span></span><br><span class="line"><span class="comment"># 创建任务的方式2</span></span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<h2 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h2><p>在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。如果需要回调多个函数，可以通过偏函数导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 17:07</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;waiting:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Done after <span class="subst">&#123;x&#125;</span> s&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">future</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;Callback:<span class="subst">&#123;future.result()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取协程对象</span></span><br><span class="line">coroutine = do_work(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># 给任务添加绑定函数</span></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<h2 id="协程阻塞"><a href="#协程阻塞" class="headerlink" title="协程阻塞"></a>协程阻塞</h2><p>使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。</p>
<h2 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 17:24</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> asyncio,time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;waiting:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Done after <span class="subst">&#123;x&#125;</span> s&quot;</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">coroutine1 = do_work(<span class="number">1</span>)</span><br><span class="line">coroutine2 = do_work(<span class="number">2</span>)</span><br><span class="line">coroutine3 = do_work(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(coroutine1),</span><br><span class="line">         asyncio.ensure_future(coroutine2),</span><br><span class="line">         asyncio.ensure_future(coroutine3)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    print(<span class="string">f&quot;task result:<span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;running time:<span class="subst">&#123;time.time()-start&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/19 17:31</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;waiting <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;done after <span class="subst">&#123;x&#125;</span> s&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建多个协程对象</span></span><br><span class="line">    <span class="comment"># 封装任务列表</span></span><br><span class="line">    coroutine1 = do_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_work(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [asyncio.ensure_future(coroutine1),</span><br><span class="line">             asyncio.ensure_future(coroutine2),</span><br><span class="line">             asyncio.ensure_future(coroutine3)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取协程返回结果的方式1</span></span><br><span class="line">    <span class="comment"># dones, pending = await asyncio.wait(tasks)</span></span><br><span class="line">    <span class="comment"># for task in dones:</span></span><br><span class="line">    <span class="comment">#     print(f&quot;result: &#123;task.result()&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取协程返回结果的方式2</span></span><br><span class="line">    <span class="comment"># results = await asyncio.gather(*tasks)</span></span><br><span class="line">    <span class="comment"># for result in results:</span></span><br><span class="line">    <span class="comment">#     print(f&quot;result: &#123;result&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取协程返回结果3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># 将main协程加入到事件循环当中</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(main())</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(<span class="string">f&quot;result: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;running time: <span class="subst">&#123;time.time()-start&#125;</span> s&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="协程停止"><a href="#协程停止" class="headerlink" title="协程停止"></a>协程停止</h2><p>创建future的时候，task为pending，事件循环调用执行的时候就是running，调用完毕自然是done，如果需要停止时间循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task。</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>OSI模型七层标准模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，上层可以调用下层完成通信。</p>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP是一个协议族，也是按照层次进行划分，共四层：应用层（应用层+会话层+表示层）、传输层、互连网络层、网络接口层（物理层+数据链路层）。</p>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>TCP协议和UDP协议是<strong>传输层</strong>的两种协议。Socket是传输层供给应用层的编程接口，所以Socket编程就分为TCP编程和UDP编程两类。</p>
<p>TCP方式就类似于打电话，使用该种方式进行网络通讯时，需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。而UDP方式就类似于发送短信，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。</p>
<p>重要数据一般使用TCP方式进行数据传输，而大量非核心数据则可以通过UDP方式传输，在一些程序中甚至结合使用这两种方式进行数据传递。</p>
<p>由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而传输时产生的数据量要比UDP稍微大一些。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ul>
<li>第一步，客户端发送一个包含SYN即同步（Synchronize）标志的TCP报文，SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</li>
<li>第二步，服务器在收到客户端的SYN报文后，将返回一个SYN+ACK的报文，表示客户端的请求被接受，同时TCP序号被加一，ACK即确认（Acknowledgement）。</li>
<li>第三步，客户端也返回一个确认报文ACK给服务器端，同样TCP序号被加一，到此一个TCP连接完成。然后才开始通信的第二步：数据处理。</li>
</ul>
<h2 id="TFTP协议"><a href="#TFTP协议" class="headerlink" title="TFTP协议"></a>TFTP协议</h2><p>TFTP协议全称为简单文件传输协议，它是以UDP为基础的<strong>应用层</strong>协议。</p>
<ul>
<li>数据传输起始于一个读取或者写入文件的请求，只有客户端才可以发送这种请求。</li>
<li>默认情况下，数据以定长512字节传输，如果服务器支持扩展选项，可以使用blksize选项协商数据长度。每个数据包中仅包含一个数据块。只有收到对方的应答数据包，才会发送下一包数据。</li>
<li>如果一个数据包数据大小小于512字节或小于通过blksize选项协商定的数据长度，表示数据传输结束。</li>
<li>两台机器进行数据传输时，一台为发送方一台为接收方。发送方发送数据并接收应答，接收方发送应答接收数据。</li>
<li>大部分的错误会导致连接中断，错误由一个错误的数据包引起，这个包不会被确认，也不会被重新发送。</li>
</ul>
<p><img src="https://my-pic-storage-1305445540.cos.ap-nanjing.myqcloud.com/202305131448838.png" alt=""></p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就能接收另外一个函数作为参数，这种函数就称为高阶函数。函数式编程就是指这种高度抽象的编程范式。</p>
<h2 id="高阶函数map"><a href="#高阶函数map" class="headerlink" title="高阶函数map"></a>高阶函数map</h2><p>map函数接收两个参数，一个是函数，一个是序列，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">nums_iter = <span class="built_in">map</span>(f, nums)</span><br><span class="line">print(<span class="string">f&quot;是否是可迭代的对象：<span class="subst">&#123;<span class="built_in">isinstance</span>(nums_iter, Iterator)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数reduce"><a href="#高阶函数reduce" class="headerlink" title="高阶函数reduce"></a>高阶函数reduce</h2><p>reduce把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce把结果和继续和序列的下一个元素做累积计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 14:47</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">total = reduce(f, a)</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数filter"><a href="#高阶函数filter" class="headerlink" title="高阶函数filter"></a>高阶函数filter</h2><p>Python内置的filter函数用于过滤序列。和map类似，filter也接收一个函数和一个序列，和map不同的是，filter把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 14:56</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, nums)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高阶函数sorted"><a href="#高阶函数sorted" class="headerlink" title="高阶函数sorted"></a>高阶函数sorted</h2><p>Python内置的sorted函数可以对list进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 15:08</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">nums = [-<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">20</span>]</span><br><span class="line">sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">print(<span class="string">f&quot;默认升序：<span class="subst">&#123;sorted_nums&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">nums = [-<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">20</span>]</span><br><span class="line">sorted_nums = <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f&quot;使用reverse降序：<span class="subst">&#123;sorted_nums&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">nums = [-<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">20</span>]</span><br><span class="line">sorted_nums = <span class="built_in">sorted</span>(nums, key=<span class="built_in">abs</span>)</span><br><span class="line">print(<span class="string">f&quot;按绝对值排序：<span class="subst">&#123;sorted_nums&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数zip"><a href="#高阶函数zip" class="headerlink" title="高阶函数zip"></a>高阶函数zip</h2><p>zip函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个可迭代对象的元素个数不一致，则返回的对象长度与最短的可迭代对象相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">c = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">zip</span>(a, b, c)))</span><br><span class="line"><span class="comment"># [(1, 4, 9), (2, 5, 10), (3, 6, 11)]</span></span><br></pre></td></tr></table></figure>
<p>利用 * 号操作符，与zip相反，进行解压。如下图例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">zip</span>(a, b)))</span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">print(*<span class="built_in">zip</span>(a, b))</span><br><span class="line"><span class="comment"># (1, 4) (2, 5) (3, 6)</span></span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">zip</span>(*<span class="built_in">zip</span>(a, b))))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在传入函数时，有时不需要显式地定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了支持，使用lambda可以声明一个匿名函数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 15:26</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">f = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line">print(f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, nums)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">students = [Student(<span class="string">&#x27;a&#x27;</span>, <span class="number">7</span>), Student(<span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>), Student(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">sorted_students = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x.age)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> sorted_students:</span><br><span class="line">    print(<span class="string">f&quot;name:<span class="subst">&#123;student.name&#125;</span>, age:<span class="subst">&#123;student.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包实际上就是一个函数，创建方式如下：</p>
<ol>
<li>要有函数的嵌套（内部函数，外部函数）</li>
<li>内部函数中要使用外部函数的变量</li>
<li>外部函数必须有返回值，返回内部函数名</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 15:41</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out</span>(<span class="params">num1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in</span>(<span class="params">num2</span>):</span></span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = fun_out(<span class="number">100</span>)</span><br><span class="line">res = f(<span class="number">200</span>)</span><br><span class="line">print(<span class="string">f&quot;两个数的和为<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dist_out</span>(<span class="params">x1, y1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_dist_in</span>(<span class="params">x2, y2</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt((x1 - x2) ** <span class="number">2</span> + (y1 - y2) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_dist_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = get_dist_out(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">res = f(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">f&quot;距离为<span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>闭包的特殊用途：在不修改源代码的前提下，添加新的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 16:30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        file.write(<span class="string">&quot;访问：&quot;</span>)</span><br><span class="line">        file.write(func.__name__)</span><br><span class="line">        file.write(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        file.write(<span class="string">&quot;时间：&quot;</span>)</span><br><span class="line">        file.write(time.asctime())</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e.args)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;功能2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in</span>():</span></span><br><span class="line">        write_log(func)</span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = fun_out(func2)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在Python中，装饰器就是一种闭包，它可以使闭包的访问方式更加简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 16:49</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = <span class="built_in">open</span>(<span class="string">&quot;decorator.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        file.write(<span class="string">&quot;访问：&quot;</span>)</span><br><span class="line">        file.write(func.__name__)</span><br><span class="line">        file.write(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        file.write(<span class="string">&quot;时间：&quot;</span>)</span><br><span class="line">        file.write(time.asctime())</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e.args)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in</span>():</span></span><br><span class="line">        write_log(func)</span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于fun_out(fun1)</span></span><br><span class="line"><span class="meta">@fun_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;功能2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure>
<p>多个装饰器同时装饰一个函数的场景下，其装饰顺序与执行顺序为：靠近原函数的先进行装饰后执行，离原函数远的后装饰先执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 17:17</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out1</span>(<span class="params">fun</span>):</span></span><br><span class="line">    print(<span class="string">&quot;装饰器1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in1</span>():</span></span><br><span class="line">        print(<span class="string">&quot;hello 1&quot;</span>)</span><br><span class="line">        fun()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out2</span>(<span class="params">fun</span>):</span></span><br><span class="line">    print(<span class="string">&quot;装饰器2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in2</span>():</span></span><br><span class="line">        print(<span class="string">&quot;hello 2&quot;</span>)</span><br><span class="line">        fun()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun_out2</span></span><br><span class="line"><span class="meta">@fun_out1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure>
<p>带参数的装饰器实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 18:40</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;访问了方法：<span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        write_log(func)</span><br><span class="line">        <span class="keyword">return</span> func(x, y)</span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;两数之和为<span class="subst">&#123;add(<span class="number">10</span>, <span class="number">20</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>对于一个函数而言，它的参数可能是一个、两个或者多个，因此需要使用一个通用的装饰器来装饰函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 18:57</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;于<span class="subst">&#123;time.asctime()&#125;</span>调用了函数<span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_out</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_in</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        write_log(func)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a - b - c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;两数之和为<span class="subst">&#123;add(<span class="number">10</span>, <span class="number">20</span>)&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;三数之差为<span class="subst">&#123;minus(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。偏函数是用于对函数固定属性的函数，作用就是把一个函数某些参数固定住（也就是设置默认值），返回一个新的函数，调用这个新的函数会更简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/16 19:11</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">new_int = partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line">print(new_int(<span class="string">&quot;10&quot;</span>))</span><br><span class="line">print(new_int(<span class="string">&quot;1010&quot;</span>))</span><br><span class="line">print(new_int(<span class="string">&quot;101010&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是对字符串操作的一种逻辑表达式，就是用事先定义好的一些特定字符及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑（可以用来做检索、截取或者替换操作）。</p>
<p>正则表述式用于搜索、替换和解析字符串。正则表达式遵循一定的语法规则，使用非常灵活，功能强大。使用正则表达式编写一些逻辑验证非常方便，例如电子邮件地址格式的验证。</p>
<p>正则表达式是对字符串（包括普通字符（例如，a到z之间的字母）和特殊字符)操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑，正则表达式是一种文本模式，模式描述在搜索文本时要匹配一个或多个字符串。</p>
<p><strong>正则表达式的作用</strong></p>
<ol>
<li>给定的字符串是否符合正则表达式的过滤逻辑（简称“匹配”）。</li>
<li>可以通过正则表达式，从字符串中获取我们想要的特定部分。</li>
<li>还可以对目标字符串进行替换操作。</li>
</ol>
<h3 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配任意一个字符（’\n’除外）</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">匹配列表中的字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母、数字、下划线，即a-z，A-Z，0-9，_</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">匹配不是字母、数字、下划线</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配空白字符，即空格（\n，\t）</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配不是空白的字符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字，即0-9</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配非数字的字符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;=================.的使用==================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">pattern = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\d的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\d&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\D的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;-&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\D&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\s的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\s&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\S的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\S&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\w的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;l&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\w&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================\W的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;\W&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================[]的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">pattern = <span class="string">&quot;[2468]&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br></pre></td></tr></table></figure>
<h3 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配零次或多次</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配一次或多次</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配一次或零次</td>
</tr>
<tr>
<td style="text-align:center">{m}</td>
<td style="text-align:center">重复m次</td>
</tr>
<tr>
<td style="text-align:center">{m,n}</td>
<td style="text-align:center">重复m到n次，其中n可以省略，表示m到任意次</td>
</tr>
<tr>
<td style="text-align:center">{m,}</td>
<td style="text-align:center">至少m次</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/17 16:47</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=================*的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;123qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d*&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================+的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;a123qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d+&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================?的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;a123qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d?&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================&#123;m&#125;的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;123qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d&#123;2&#125;&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================&#123;m,n&#125;的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;123456qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d&#123;2,5&#125;&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(<span class="string">&quot;=================&#123;m,&#125;的使用=================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;123456qwe&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;\d&#123;2,&#125;&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br></pre></td></tr></table></figure>
<h3 id="边界字符"><a href="#边界字符" class="headerlink" title="边界字符"></a>边界字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串开头</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串结尾</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配一个单词的边界</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词的边界</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/18 10:51</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;===============$的使用=================&quot;</span>)</span><br><span class="line"><span class="comment"># 匹配5-10位的QQ邮箱，开头数字不能是0</span></span><br><span class="line">pattern = <span class="string">r&quot;[1-9]\d&#123;4,9&#125;@qq.com$&quot;</span></span><br><span class="line"><span class="comment"># 可以匹配</span></span><br><span class="line"><span class="comment"># qq = r&quot;12345@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 不可以匹配</span></span><br><span class="line">qq = <span class="string">r&quot;12345@qq.com.126.com&quot;</span></span><br><span class="line">o = re.match(pattern, qq)</span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;===============^的使用=================&quot;</span>)</span><br><span class="line">pattern = <span class="string">r&quot;^hello&quot;</span></span><br><span class="line">s = <span class="string">r&quot;hello python&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">print(<span class="string">r&quot;===============\b左边界的使用=================&quot;</span>)</span><br><span class="line">pattern = <span class="string">r&quot;.*\bhello&quot;</span></span><br><span class="line">s = <span class="string">r&quot;python hello python&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">print(<span class="string">r&quot;===============\b右边界的使用=================&quot;</span>)</span><br><span class="line">pattern = <span class="string">r&quot;.*python\b&quot;</span></span><br><span class="line">s = <span class="string">r&quot;python hello python&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line">print(<span class="string">r&quot;===============\B非单词边界的使用=================&quot;</span>)</span><br><span class="line">pattern = <span class="string">r&quot;.*python\B&quot;</span></span><br><span class="line">s = <span class="string">r&quot;hello pythonhello&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br></pre></td></tr></table></figure>
<h3 id="择一匹配字符"><a href="#择一匹配字符" class="headerlink" title="择一匹配字符"></a>择一匹配字符</h3><p>search方法搜索一个字符串，要想搜索多个字符串，如搜索aa、bb和cc，最简单的方法是在文本模式字符串中使用择一匹配符号（|）。择一匹配符号和逻辑或类似，只要满足任何一个就算匹配成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&quot;aa|bb|cc&quot;</span></span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配0-100的所有数字</span></span><br><span class="line">pattern = <span class="string">r&quot;[1-9][0-9]$|100$&quot;</span></span><br><span class="line">s = <span class="string">&quot;123&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br></pre></td></tr></table></figure>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>如果一个模式字符串中有用一堆圆括号括起来的部分，那么这部分就会作为一组，可以通过group方法的参数获取指定的组匹配的字符串。当然，如果模式字符串中没有任何用圆括号括起来的部分，那么就不会对待匹配的字符串进行分组。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(ab)</td>
<td style="text-align:center">将括号中的字符作为一个分组</td>
</tr>
<tr>
<td style="text-align:center">\num</td>
<td style="text-align:center">引用分组num匹配到的字符串</td>
</tr>
<tr>
<td style="text-align:center">(?P<name>)</td>
<td style="text-align:center">分组起别名</td>
</tr>
<tr>
<td style="text-align:center">(?P=name)</td>
<td style="text-align:center">引用别名为name分组匹配到的字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @Author 坦克手贝塔</span></span><br><span class="line"><span class="string">    @Date 2023/5/18 11:39</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;================分组的使用===============&quot;</span>)</span><br><span class="line"><span class="comment"># 匹配座机号码，区号&#123;3,4&#125;-电话号码&#123;5,8&#125;</span></span><br><span class="line">pattern = <span class="string">r&quot;(\d&#123;3,4&#125;)-([1-9]\d&#123;4,7&#125;$)&quot;</span></span><br><span class="line">s = <span class="string">&quot;010-1234567&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(o.groups())</span><br><span class="line">print(o.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配网页的标签数据</span></span><br><span class="line"><span class="comment"># pattern = r&#x27;&lt;.+&gt;&lt;.+&gt;.+&lt;/.+&gt;&lt;/.+&gt;&#x27;</span></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;(.+)&gt;&lt;(.+)&gt;.+&lt;/\2&gt;&lt;/\1&gt;&#x27;</span></span><br><span class="line">s1 = <span class="string">&quot;&lt;html&gt;&lt;head&gt;这是head部分&lt;/head&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">o1 = re.match(pattern, s1)</span><br><span class="line">print(o1)</span><br><span class="line">s2 = <span class="string">&quot;&lt;html&gt;&lt;head&gt;这是head部分&lt;/head&gt;&lt;/body&gt;&quot;</span></span><br><span class="line">o2 = re.match(pattern, s2)</span><br><span class="line">print(o2)</span><br><span class="line"><span class="comment"># 分组起别名</span></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;(?P&lt;k_html&gt;.+)&gt;&lt;(?P&lt;k_head&gt;.+)&gt;.+&lt;/(?P=k_head)&gt;&lt;/(?P=k_html)&gt;&#x27;</span></span><br><span class="line">s1 = <span class="string">&quot;&lt;html&gt;&lt;head&gt;这是head部分&lt;/head&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">o1 = re.match(pattern, s1)</span><br><span class="line">print(o1)</span><br><span class="line">s2 = <span class="string">&quot;&lt;html&gt;&lt;head&gt;这是head部分&lt;/head&gt;&lt;/body&gt;&quot;</span></span><br><span class="line">o2 = re.match(pattern, s2)</span><br><span class="line">print(o2)</span><br></pre></td></tr></table></figure>
<h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>可选标志位，即flags参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">re.I</td>
<td style="text-align:center">使匹配对大小写不敏感</td>
</tr>
<tr>
<td style="text-align:center">re.L</td>
<td style="text-align:center">做本地化识别（local-aware）匹配</td>
</tr>
<tr>
<td style="text-align:center">re.M</td>
<td style="text-align:center">多行匹配，影响’^’和’$’</td>
</tr>
<tr>
<td style="text-align:center">re.S</td>
<td style="text-align:center">使’.’匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td style="text-align:center">re.U</td>
<td style="text-align:center">根据Unicode字符集解析字符，这个标志影响’\w’，’\W’，’\b’，’\B’</td>
</tr>
<tr>
<td style="text-align:center">re.X</td>
<td style="text-align:center">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># match方法</span></span><br><span class="line">print(<span class="string">&quot;==============================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;hello python hello&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;hello&quot;</span></span><br><span class="line">o = re.match(pattern, s)</span><br><span class="line">print(o)</span><br><span class="line">print(o.group())</span><br><span class="line">print(o.span())</span><br><span class="line">print(o.start())</span><br><span class="line">print(<span class="string">&quot;============flags=============&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;hello python hello&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">o = re.match(pattern, s, re.I)</span><br><span class="line">print(o)</span><br><span class="line">print(o.group())</span><br><span class="line">print(o.span())</span><br><span class="line">print(o.start())</span><br></pre></td></tr></table></figure>
<h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p>search在一个字符串中搜索满足文本模式的字符串。与match方法的不同之处在于match从头开始匹配，search是在整个字符串中寻找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&quot;I love python&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;love&quot;</span></span><br><span class="line">o1 = re.search(pattern, s)</span><br><span class="line">print(o1)</span><br><span class="line">o2 = re.match(pattern, s)</span><br><span class="line">print(o2)</span><br></pre></td></tr></table></figure>
<h3 id="sub和subn函数"><a href="#sub和subn函数" class="headerlink" title="sub和subn函数"></a>sub和subn函数</h3><p>sub和subn函数用于实现搜索和替换功能。这两个函数的功能几乎完全相同，都是将某个字符串中所有匹配正则表达式的部分替换成其他字符串。用来替换的部分可能是一个字符串，也可以是一个函数，该函数返回一个用来替换的字符串。sub函数返回替换后的结果，subn函数返回一个元组，元组的第一个元素是替换后的结果，第二个元素是替换的总数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====================sub和subn========================&quot;</span>)</span><br><span class="line"><span class="comment"># 将phone中的注释去掉</span></span><br><span class="line">phone = <span class="string">&quot;010-234567-78979 # 这是一个电话号码&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;#.*$&quot;</span></span><br><span class="line">res = re.sub(pattern, <span class="string">&#x27;&#x27;</span>, phone)</span><br><span class="line">print(res)</span><br><span class="line">res = re.subn(pattern, <span class="string">&#x27;&#x27;</span>, phone)</span><br><span class="line">print(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="compile函数"><a href="#compile函数" class="headerlink" title="compile函数"></a>compile函数</h3><p>compile函数用于编译正则表达式，生成一个正则表达式对象，供match和search这两个函数使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;=====================compile========================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;first123 line&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\w+&quot;</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">res = regex.match(s)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="findall函数"><a href="#findall函数" class="headerlink" title="findall函数"></a>findall函数</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;=====================findall========================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;first 1 second 2 third 3&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\w+&quot;</span></span><br><span class="line">res = re.findall(pattern, s)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="finditer函数"><a href="#finditer函数" class="headerlink" title="finditer函数"></a>finditer函数</h3><p>和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;=====================finditer========================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;first 1 second 2 third 3&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\w+&quot;</span></span><br><span class="line">res = re.finditer(pattern, s)</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> res:</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
<h3 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h3><p>split函数用于根据正则表达式分隔字符，也就是说，将字符串与模式匹配的子字符串都作为分隔符来分隔这个字符串。split函数返回一个列表形式的分隔结果，每一个列表元素都是分隔的子字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;=====================split========================&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;first 11 second 22 third 33&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\d+&quot;</span></span><br><span class="line">res = re.split(pattern, s)</span><br><span class="line">print(res)</span><br><span class="line">res = re.split(pattern, s, <span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h3><p>贪婪模式指python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符。非贪婪模式与贪婪模式相反，总是尝试匹配尽可能少的字符，可以使用’*’，’?’，’+’，’{m,n}’后面加上?，使得贪婪变成非贪婪。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(<span class="string">&quot;==============================贪婪模式===============================&quot;</span>)</span><br><span class="line">v = re.match(<span class="string">r&#x27;(.+)(\d+-\d+-\d+)&#x27;</span>, <span class="string">&quot;this is my tel:133-1234-1234&quot;</span>)</span><br><span class="line">print(v.group(<span class="number">1</span>))</span><br><span class="line">print(v.group(<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&quot;==============================非贪婪模式===============================&quot;</span>)</span><br><span class="line">v = re.match(<span class="string">r&#x27;(.+?)(\d+-\d+-\d+)&#x27;</span>, <span class="string">&quot;this is my tel:133-1234-1234&quot;</span>)</span><br><span class="line">print(v.group(<span class="number">1</span>))</span><br><span class="line">print(v.group(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h3 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h3><p>在<code>python</code>中，<code>type</code>是一个类型而不是内置函数，该类重载了初始化方法<code>__init__</code>，因此其主要有两种用法。第一种是常见的判断对象属于什么类型，传入一个参数，基本用法为<code>type(object)</code>；第二种是返回新的类型对象，传入三个参数，基本用法为<code>type(name, bases, dict)</code>，<code>name</code>为类的名称，<code>bases</code>为基类的元组，<code>dict</code>为类内定义的命名空间变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type</span>:</span></span><br><span class="line">    <span class="comment"># object.__base__ is None. Otherwise, it would be a type.</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__base__</span>(<span class="params">self</span>) -&gt; type | <span class="keyword">None</span>:</span> ...</span><br><span class="line">    __bases__: <span class="built_in">tuple</span>[<span class="built_in">type</span>, ...]</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__basicsize__</span>(<span class="params">self</span>) -&gt; int:</span> ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dict__</span>(<span class="params">self</span>) -&gt; types.MappingProxyType[str, Any]:</span> ...  <span class="comment"># type: ignore[override]</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dictoffset__</span>(<span class="params">self</span>) -&gt; int:</span> ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__flags__</span>(<span class="params">self</span>) -&gt; int:</span> ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__itemsize__</span>(<span class="params">self</span>) -&gt; int:</span> ...</span><br><span class="line">    __module__: <span class="built_in">str</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mro__</span>(<span class="params">self</span>) -&gt; tuple[type, ...]:</span> ...</span><br><span class="line">    __name__: <span class="built_in">str</span></span><br><span class="line">    __qualname__: <span class="built_in">str</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__text_signature__</span>(<span class="params">self</span>) -&gt; str | <span class="keyword">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__weakrefoffset__</span>(<span class="params">self</span>) -&gt; int:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, o: <span class="built_in">object</span>, /</span>) -&gt; <span class="keyword">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, bases: <span class="built_in">tuple</span>[<span class="built_in">type</span>, ...], <span class="built_in">dict</span>: <span class="built_in">dict</span>[<span class="built_in">str</span>, Any], /, **kwds: Any</span>) -&gt; <span class="keyword">None</span>:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, o: <span class="built_in">object</span>, /</span>) -&gt; type:</span> ...</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        cls: <span class="built_in">type</span>[_typeshed.Self], name: <span class="built_in">str</span>, bases: <span class="built_in">tuple</span>[<span class="built_in">type</span>, ...], namespace: <span class="built_in">dict</span>[<span class="built_in">str</span>, Any], /, **kwds: Any</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; _typeshed.Self:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args: Any, **kwds: Any</span>) -&gt; Any:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasses__</span>(<span class="params">self: _typeshed.Self</span>) -&gt; list[_typeshed.Self]:</span> ...</span><br><span class="line">    <span class="comment"># Note: the documentation doesn&#x27;t specify what the return type is, the standard</span></span><br><span class="line">    <span class="comment"># implementation seems to be returning a list.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mro</span>(<span class="params">self</span>) -&gt; list[type]:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__instancecheck__</span>(<span class="params">self, instance: Any, /</span>) -&gt; bool:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasscheck__</span>(<span class="params">self, subclass: <span class="built_in">type</span>, /</span>) -&gt; bool:</span> ...</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span>(<span class="params">metacls, name: <span class="built_in">str</span>, bases: <span class="built_in">tuple</span>[<span class="built_in">type</span>, ...], /, **kwds: Any</span>) -&gt; MutableMapping[str, object]:</span> ...</span><br><span class="line">    <span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__or__</span>(<span class="params">self, value: Any, /</span>) -&gt; types.UnionType:</span> ...</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span>(<span class="params">self, value: Any, /</span>) -&gt; types.UnionType:</span> ...</span><br><span class="line">    <span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">12</span>):</span><br><span class="line">        __type_params__: <span class="built_in">tuple</span>[TypeVar | ParamSpec | TypeVarTuple, ...]</span><br></pre></td></tr></table></figure>
<h2 id="一些库的使用"><a href="#一些库的使用" class="headerlink" title="一些库的使用"></a>一些库的使用</h2><h3 id="bisect库"><a href="#bisect库" class="headerlink" title="bisect库"></a>bisect库</h3><p>bisect()和bisect_right()等同，那下面就介绍bisect_left()和bisec_right()的区别！</p>
<p><strong>列表中没有元素x</strong>，bisect_left(ls, x)和bisec_right(ls, x)返回相同的值，该值是x在ls中“<strong>合适的插入点索引，使得数组有序</strong>”。</p>
<p><strong>列表中只有一个元素等于x</strong>，那么bisect_left(ls, x)的值是x在ls中的<strong>索引</strong>，ls[index2] = x。而bisec_right(ls, x)的值是x在ls中的<strong>索引加1</strong>。</p>
<p><strong>列表中存在多个元素等于x</strong>，那么bisect_left(ls, x)返回<strong>最左边的那个索引</strong>，此时ls[index2] = x。bisect_right(ls, x)返回<strong>最右边的那个索引加1</strong>。</p>
<h3 id="heapq库"><a href="#heapq库" class="headerlink" title="heapq库"></a>heapq库</h3><p> heapq库中的堆默认是<strong>最小堆</strong>，即树种各个父节点的值总是小于或等于任何一个子节点的值。</p>
<p><strong>heappush()</strong></p>
<p>将item压入到堆数组heap中。如果不进行此步操作，后面的heappop()失效，会直接返回原列表第一个值，而且必须从头开始heappush，不然也会返回原列表第一个值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">63</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heappush(a, <span class="number">123</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [12, 2, 4, 5, 63, 3, 2, 123]</span></span><br><span class="line">b = heapq.heappop(a)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<p><strong>heappop()</strong></p>
<p>删除并返回最小值，因为堆的特征是heap[0]永远是最小的元素，所以一般都是删除第一个元素。注意，如果不是压入堆中，而是通过append追加一个数值，堆的函数并不能操作这个增加的数值，或者说它堆对来讲是不存在的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">heapq.heappush(a, <span class="number">11</span>)</span><br><span class="line">heapq.heappush(a, <span class="number">2</span>)</span><br><span class="line">heapq.heappush(a, <span class="number">3</span>)</span><br><span class="line">heapq.heappush(a, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">1</span>)</span><br><span class="line">b = heapq.heappop(a)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p><strong>heapify()</strong></p>
<p>参数必须是list，此函数将list变成堆，实时操作。从而能够在任何情况下使用堆的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">63</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(a)</span><br><span class="line">b = heapq.heappop(a)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p><strong>heapq.heappushpop()</strong></p>
<p>是上述heappush和heappop的合体，同时完成两者的功能，注意：相当于先操作了heappush()，然后操作heappop()</p>
<p><strong>heapq.heapreplace()</strong></p>
<p>是上述heappop和heappush的联合操作。注意：与heappushpop()的区别在于，顺序不同，这里是先进行删除，后压入堆。</p>
<p><strong>heapq.merge()</strong></p>
<p>将多个堆合并。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">c = heapq.merge(a, b)</span><br><span class="line"><span class="keyword">for</span> cc <span class="keyword">in</span> c:</span><br><span class="line">    print(cc, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment"># 1 2 3 4 5 6 </span></span><br></pre></td></tr></table></figure>
<p><strong>heapq.nlargest()</strong></p>
<p>查询堆中的最大n个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, -<span class="number">4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))</span><br><span class="line"><span class="comment"># [42, 37, 23]</span></span><br></pre></td></tr></table></figure>
<p><strong>heapq.nsmallest()</strong></p>
<p>查询堆中的最小n个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, -<span class="number">4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums))</span><br><span class="line"><span class="comment"># [-4, 1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="functools库"><a href="#functools库" class="headerlink" title="functools库"></a>functools库</h3><p><strong>cmp_to_key</strong></p>
<p>可以将一个cmp函数变成一个key函数，从而支持自定义排序。具体用法是，定义一个函数，接受两个变量x和y，然后返回值如果大于1说明在排序的数组中x在y后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">new_nums = <span class="built_in">sorted</span>(nums, key=cmp_to_key(<span class="keyword">lambda</span> x, y: y - x))</span><br><span class="line">new_nums2 = <span class="built_in">sorted</span>(nums, key=cmp_to_key(<span class="keyword">lambda</span> x, y: x - y))</span><br><span class="line">print(new_nums)</span><br><span class="line">print(new_nums2)</span><br><span class="line"><span class="comment"># [34, 30, 9, 5, 3]</span></span><br><span class="line"><span class="comment"># [3, 5, 9, 30, 34]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">nums2 = <span class="built_in">map</span>(<span class="built_in">str</span>, nums)</span><br><span class="line">new_nums2 = <span class="built_in">sorted</span>(nums2, key=cmp_to_key(<span class="keyword">lambda</span> x, y: <span class="built_in">int</span>(x + y) - <span class="built_in">int</span>(y + x)))</span><br><span class="line">print(new_nums2)</span><br><span class="line"><span class="comment"># [&#x27;30&#x27;, &#x27;3&#x27;, &#x27;34&#x27;, &#x27;5&#x27;, &#x27;9&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="argparse库"><a href="#argparse库" class="headerlink" title="argparse库"></a>argparse库</h3><p>argparse模块是Python内置的用于命令项选项与参数解析的模块，argparse模块可以让人轻松编写用户友好的命令行接口，能够帮助程序员为模型定义参数。</p>
<h4 id="argparse定义四个步骤"><a href="#argparse定义四个步骤" class="headerlink" title="argparse定义四个步骤"></a>argparse定义四个步骤</h4><ol>
<li>导入argparse包 ——import argparse</li>
<li>创建一个命令行解析器对象 ——创建 ArgumentParser() 对象</li>
<li>给解析器添加命令行参数 ——调用add_argument() 方法添加参数</li>
<li>解析命令行的参数 ——使用 parse_args() 解析添加的参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个命令行解析对象</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加命令行参数</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;--epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">100</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--batch&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 从命令行中结构化解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure>
<h3 id="os库"><a href="#os库" class="headerlink" title="os库"></a>os库</h3><h4 id="os-path-realpath和os-path-abspath"><a href="#os-path-realpath和os-path-abspath" class="headerlink" title="os.path.realpath和os.path.abspath"></a>os.path.realpath和os.path.abspath</h4><p><code>os.path.realpath</code>返回的是使用软链接的真实地址，<code>os.path.abspath</code>返回目标地址。如下所示，首先创建文件<code>a.txt</code>；随后创建软链接<code>b.txt</code>；最后分别测试<code>abspath</code>和<code>realpath</code>的返回值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">touch a.txt</span><br><span class="line"></span><br><span class="line">ln -s  a.txt  b.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import os</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.path.abspath(<span class="string">&quot;a.txt&quot;</span>)</span></span><br><span class="line">&#x27;/home/ubuntu/xxx/workspace/demo/a.txt&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.path.abspath(<span class="string">&quot;b.txt&quot;</span>)</span></span><br><span class="line">&#x27;/home/ubuntu/xxx/workspace/demo/b.txt&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.path.realpath(<span class="string">&quot;a.txt&quot;</span>)</span></span><br><span class="line">&#x27;/home/ubuntu/xxx/workspace/demo/a.txt&#x27;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.path.realpath(<span class="string">&quot;b.txt&quot;</span>)</span></span><br><span class="line">&#x27;/home/ubuntu/xxx/workspace/demo/a.txt&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="函数与方法辨析"><a href="#函数与方法辨析" class="headerlink" title="函数与方法辨析"></a>函数与方法辨析</h1><p>在标准库<code>inspect</code>中，它提供了两个自省的函数，即<code>ismethod()</code>和<code>isfunction()</code>，可以用来判断什么是方法，什么是函数。</p>
<ul>
<li><p><code>isfunction()</code>判断出的是用户定义的函数（<code>user-defined function</code>）， 它拥有<code>__doc__</code>、<code>__name__</code>等属性，其主要作用是判断一个对象（<code>object</code>）是否是<code>types.FunctionType</code>的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfunction</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return true if the object is a user-defined function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function objects provide these attributes:</span></span><br><span class="line"><span class="string">        __doc__         documentation string</span></span><br><span class="line"><span class="string">        __name__        name with which this function was defined</span></span><br><span class="line"><span class="string">        __code__        code object containing compiled function bytecode</span></span><br><span class="line"><span class="string">        __defaults__    tuple of any default values for arguments</span></span><br><span class="line"><span class="string">        __globals__     global namespace in which this function was defined</span></span><br><span class="line"><span class="string">        __annotations__ dict of parameter annotations</span></span><br><span class="line"><span class="string">        __kwdefaults__  dict of keyword only parameters with defaults&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isinstance</span>(<span class="built_in">object</span>, types.FunctionType)</span><br></pre></td></tr></table></figure></li>
<li><p><code>ismethod()</code>判断出的是实例方法（<code>instance method</code>）， 它拥有函数的一些属性，最特别的是还有一个<code>__self__</code>属性，其主要作用是判断一个对象（<code>object</code>）是否是<code>types.MethodType</code>的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ismethod</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return true if the object is an instance method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instance method objects provide these attributes:</span></span><br><span class="line"><span class="string">        __doc__         documentation string</span></span><br><span class="line"><span class="string">        __name__        name with which this method was defined</span></span><br><span class="line"><span class="string">        __func__        function object containing implementation of method</span></span><br><span class="line"><span class="string">        __self__        instance to which this method is bound&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isinstance</span>(<span class="built_in">object</span>, types.MethodType)</span><br></pre></td></tr></table></figure>
<h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2></li>
</ul>
<ol>
<li><p>非用户定义的函数，即内置函数，在<code>isfunction()/ismethod()</code>眼里并不是“函数/方法”（<code>FunctionType/MethodType</code>）！事实上，它们有专属的类别（<code>BuiltinFunctionType</code>、<code>BuiltinMethodType</code>），<code>BuiltinFunctionType</code>和<code>BuiltinMethodType</code>的类型是相同的，都指向类型<code>builtin_function_or_method</code>。例如，<code>len()</code>和<code>[].append</code>的类型都为<code>builtin_function_or_method</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(<span class="built_in">len</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(<span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(<span class="built_in">list</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(<span class="built_in">dir</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(<span class="built_in">range</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(<span class="built_in">len</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(<span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(<span class="built_in">list</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(<span class="built_in">dir</span>))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(<span class="built_in">range</span>))</span><br><span class="line">print(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(types.BuiltinFunctionType <span class="keyword">is</span> types.BuiltinMethodType)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">len</span>)==types.BuiltinMethodType)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">len</span>)==types.BuiltinFunctionType)</span><br><span class="line"><span class="comment"># &lt;class &#x27;builtin_function_or_method&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">len</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">type</span>([].append)==types.BuiltinMethodType)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">type</span>([].append)==types.BuiltinFunctionType)</span><br><span class="line"><span class="comment"># &lt;class &#x27;builtin_function_or_method&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>([].append))</span><br><span class="line">print(<span class="string">&quot;-------------------------&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>一个类的静态方法，在<code>ismethod()</code>眼里并不是方法（<code>MethodType</code>）！对于<code>class_method</code>，无论是类调用和实例调用，都存在隐式传参，为方法。对于<code>instance_method</code>，虽然属于实例方法，但不用调用方式得到不同结果，当实例调用时，存在隐式传参，为方法；当类调用时，不存在隐式传参，为函数。对于<code>static_method</code>，调用时不存在隐式传参，为函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(A.class_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.isfunction(A.instance_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.isfunction(A.static_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.ismethod(A.class_method))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(A.instance_method))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(A.static_method))</span><br><span class="line">print(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(a.class_method))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.isfunction(a.instance_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.isfunction(a.static_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.ismethod(a.class_method))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(inspect.ismethod(a.instance_method))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(inspect.ismethod(a.static_method))</span><br><span class="line">print(<span class="string">&quot;------------------------&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="多线程-多进程"><a href="#多线程-多进程" class="headerlink" title="多线程/多进程"></a>多线程/多进程</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h3><p>锁是一种同步机制，用于控制对共享资源的访问。当一个进程或线程获取锁后，它就拥有了对该资源的独占访问权。在此期间，其他尝试获取锁的进程或线程会被阻塞，直到锁被释放。</p>
<h3 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h3><p>临界区是指访问共享资源的一段代码。为了避免竞态条件（race condition），在同一时间只能有一个进程或线程执行这段代码。锁用于确保同一时间只有一个进程或线程进入临界区。</p>
<h3 id="条件变量（Condition）"><a href="#条件变量（Condition）" class="headerlink" title="条件变量（Condition）"></a>条件变量（Condition）</h3><p>条件变量通常用于进程间通信和同步。它们是基于锁（Lock或RLock）实现的，提供了一种在特定条件下等待和通知其他进程的机制。条件变量有以下几个主要方法：</p>
<ul>
<li><code>acquire()</code>: 获取锁。</li>
<li><code>release()</code>: 释放锁。</li>
<li><code>wait()</code>: 释放锁并进入等待状态，直到被 <code>notify()</code> 或 <code>notify_all()</code> 唤醒。</li>
<li><code>notify()</code>: 唤醒一个等待的进程。</li>
<li><code>notify_all()</code>: 唤醒所有等待的进程。</li>
</ul>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> receiving_condition:</span><br><span class="line">    <span class="keyword">while</span> num_receptions.value &lt; training_freq:</span><br><span class="line">        receiving_condition.wait()</span><br><span class="line">    data = mem_pool.sample(size=batch_size)</span><br><span class="line">    num_receptions.value -= training_freq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><code>with receiving_condition:</code>这行代码会调用<code>receiving_condition.acquire()</code>，获取<code>receiving_condition</code>的锁。</li>
<li><code>while num_receptions.value &lt; training_freq:</code>这行代码进入<code>while</code>循环，检查<code>num_receptions.value</code>是否小于<code>training_freq</code>。</li>
<li><code>receiving_condition.wait()</code>这行代码首先释放当前持有的锁，这允许其他等待该锁的进程可以获取锁并执行它们的代码；其次让当前进程进入等待状态，直到被<code>receiving_condition.notify()</code>或<code>receiving_condition.notify_all()</code>唤醒。</li>
<li>当另一个进程调用<code>receiving_condition.notify()</code>或<code>receiving_condition.notify_all()</code>时，当前等待的进程会被唤醒，并尝试重新获取锁。一旦锁被重新获取，<code>wait()</code>方法返回，进程继续执行后续代码。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%80%BB%E7%BB%93/" rel="tag"># 总结</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/02/Paper-Ideas/" rel="prev" title="Paper Ideas">
                  <i class="fa fa-chevron-left"></i> Paper Ideas
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式">
                  设计模式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木霈玖</span>
</div>

    </div>
  </footer>

  
  <script src="//unpkg.com/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//unpkg.com/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
